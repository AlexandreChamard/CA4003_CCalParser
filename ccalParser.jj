
options
{
IGNORE_CASE = true;
}

PARSER_BEGIN(SyntaxChecker)

import java.util.ArrayList;

interface Show {
    String toString(JsonShowHelper jsh);
}


enum Type {
    INVALID,
    VOID,
    INTEGER,
    BOOLEAN
}

interface Typeable {
    Type getType() throws ParseException;
    ArrayList<Type> getComplexType();
    boolean isLiteral();
}


class Program implements Show {
    public String toString(JsonShowHelper jsh) {
        return "";
    }
}

class Declaration implements Show {
    public String toString(JsonShowHelper jsh) {
        return "";
    }

}

class Function implements Show {
    public String toString(JsonShowHelper jsh) {
        return "";
    }

}

class Main implements Show {
    public String toString(JsonShowHelper jsh) {
        return "";
    }

}

abstract class Statement implements Show {

}

class VariableDeclaration extends Statement {
    public String toString(JsonShowHelper jsh) {
        return "";
    }

}

class IfStatement extends Statement {
    public String toString(JsonShowHelper jsh) {
        return "";
    }

}

class WhileStatement extends Statement {
    public String toString(JsonShowHelper jsh) {
        return "";
    }
}

class SkipStatement extends Statement {
    public String toString(JsonShowHelper jsh) {
        return "";
    }
}

class ReturnStatement extends Statement {
    public String toString(JsonShowHelper jsh) {
        return "";
    }
}

class ExpressionStatement extends Statement {
    public String toString(JsonShowHelper jsh) {
        return "";
    }
}


abstract class Expression implements Show, Typeable {
    public ArrayList<Type> getComplexType() { return new ArrayList(); }
    public boolean isLiteral() { return false; }

    public void checkValidity() throws ParseException {
        if (getType() == Type.INVALID)
            throw new ParseException("some types are invalid.");
    }
}

class AssignmentExpression extends Expression {
    private Expression e1, e2;

    AssignmentExpression(Expression _e1, Expression _e2) throws ParseException {
        e1 = _e1;
        e2 = _e2;
        checkValidity();
    }

    public Type getType() throws ParseException {
        Type t1 = e1.getType(), t2 = e2.getType();

        if (t1 != Type.INVALID && t1 != Type.VOID && t1 == t2)
            return t1;
        return Type.INVALID;
    }

    public String toString(JsonShowHelper jsh) {
        return "{\n"
            +jsh.increase() + "\"type\": \"AssignmentExpression\",\n"
            +jsh.spaces + "\"operator\": \"=\",\n"
            +jsh.spaces + "\"left\": " + e1.toString(jsh) + ",\n"
            +jsh.spaces + "\"right\": " + e2.toString(jsh) + "\n"
            +jsh.decrease() + "}";
    }
}

class LogicalExpression extends Expression {
    private String operator;
    private Expression e1, e2;

    LogicalExpression(String _operator, Expression _e1, Expression _e2) throws ParseException {
        operator = _operator;
        e1 = _e1;
        e2 = _e2;
        checkValidity();
    }

    public Type getType() throws ParseException {
        Type t1 = e1.getType(), t2 = e2.getType();

        if (t1 == Type.BOOLEAN && t2 == Type.BOOLEAN) {
            if (e1.isLiteral() == true || e2.isLiteral() == true)
                throw new ParseException("Invalid Logical Expression on Literal."); // because ccal
            return Type.BOOLEAN;
        }
        return Type.INVALID;
    }

    public String toString(JsonShowHelper jsh) {
        return "{\n"
            +jsh.increase() + "\"type\": \"LogicalExpression\",\n"
            +jsh.spaces + "\"operator\": \"" + operator + "\",\n"
            +jsh.spaces + "\"left\": " + e1.toString(jsh) + ",\n"
            +jsh.spaces + "\"right\": " + e2.toString(jsh) + "\n"
            +jsh.decrease() + "}";
    }
}

class BinaryExpression extends Expression {
    private String operator;
    private Expression e1, e2;

    BinaryExpression(String _operator, Expression _e1, Expression _e2) throws ParseException {
        operator = _operator;
        e1 = _e1;
        e2 = _e2;
        checkValidity();
    }

    public Type getType() throws ParseException {
        Type t1 = e1.getType(), t2 = e2.getType();

        switch (operator) {
            case "+": case "-":
                if (t1 == Type.INTEGER && t2 == Type.INTEGER)
                    return Type.INTEGER;
                return Type.INVALID;
            case "<": case "<=": case ">": case ">=":
                if (t1 == Type.INTEGER && t2 == Type.INTEGER)
                    return Type.BOOLEAN;
                return Type.INVALID;
            case "==": case "!=":
                if (t1 != Type.INVALID && t1 != Type.VOID && t1 == t2)
                    return Type.BOOLEAN;
                return Type.INVALID;
            default:
                return Type.INVALID; // normaly unreachable
        }
    }

    public String toString(JsonShowHelper jsh) {
        return "{\n"
            +jsh.increase() + "\"type\": \"BinaryExpression\",\n"
            +jsh.spaces + "\"operator\": \"" + operator + "\",\n"
            +jsh.spaces + "\"left\": " + e1.toString(jsh) + ",\n"
            +jsh.spaces + "\"right\": " + e2.toString(jsh) + "\n"
            +jsh.decrease() + "}";
    }
}

class UnaryExpression extends Expression {
    private String operator;
    private Expression e;

    UnaryExpression(String _operator, Expression _e) throws ParseException {
        operator = _operator;
        e = _e;
        checkValidity();
    }

    public Type getType() throws ParseException {
        switch (operator) {
            case "-":
                if (e.getType() == Type.INTEGER)
                    return  Type.INTEGER;
                return Type.INVALID;
            case "~":
                if (e.getType() == Type.BOOLEAN) {
                    if (e.isLiteral() == true)
                        throw new ParseException("Invalid Unary '~` on Literal."); // because ccal
                    return  Type.BOOLEAN;
                }
            default:
                return Type.INVALID;
        }
    }

    public String toString(JsonShowHelper jsh) {
        return "{\n"
            +jsh.increase() + "\"type\": \"UnaryExpression\",\n"
            +jsh.spaces + "\"operator\": \"" + operator + "\",\n"
            +jsh.spaces + "\"argument\": " + e.toString(jsh) + "\n"
            +jsh.decrease() + "}";
    }
}

class CallExpression extends Expression {
    public Type getType() throws ParseException { return Type.VOID; }
    
    public String toString(JsonShowHelper jsh) {
        return "";
    }
}

class Identifier extends Expression {
    private Token id;

    Identifier(Token _id) {
        id = _id;
    }

    public Type getType() throws ParseException {
        /** check in identifier hashtable */
        return Type.VOID;
    }

    public String toString(JsonShowHelper jsh) {
        return "{\n"
            +jsh.increase() + "\"type\": \"Identifier\",\n"
            +jsh.spaces + "\"name\": \"" + id + "\"\n"
            +jsh.decrease() + "}";
    }
}

abstract class Literal extends Expression {
    public boolean isLiteral() { return true; }
}

class Number extends Literal {
    private String value;

    public Number(String _value) {
        value = _value;
    }

    public Type getType() throws ParseException {
        return Type.INTEGER;
    }

    public String toString(JsonShowHelper jsh) {
        return "{\n"
            +jsh.increase() + "\"type\": \"Literal\",\n"
            +jsh.spaces + "\"value\": " + value + "\n"
            +jsh.decrease() + "}";
    }
}

class Bool extends Literal {
    private boolean value;

    Bool(boolean _value) {
        value = _value;
    }

    public Type getType() throws ParseException {
        return Type.BOOLEAN;
    }

    public String toString(JsonShowHelper jsh) {
        return "{\n"
            +jsh.increase() + "\"type\": \"Literal\",\n"
            +jsh.spaces + "\"value\": " + Boolean.toString(value) + "\n"
            +jsh.decrease() + "}";
    }
}


//////////////////
///    MAIN    ///
//////////////////
public class SyntaxChecker {
    public static void main(String[] args) {
        SyntaxChecker parser;

        if (args.length == 0) {
            System.out.println("SLP Parser: Reading from standard input . . .");
            parser = new SyntaxChecker(System.in);
        } else if (args.length == 1 && args[0].equals("-h") == false && args[0].equals("--help") == false) {
            try {
                parser = new SyntaxChecker(new java.io.FileInputStream(args[0]));
            } catch (java.io.FileNotFoundException e) {
                System.out.println("SLP Parser: File " + args[0] + " not found.");
                System.exit(1);
                return;
            }

        } else {

            System.out.println("");
            System.out.println("USAGE:");
            System.out.println("\tjava SyntaxChecker [inputfile.ccal]");
            System.out.println("");
            return;

        }

        try {
            Expression e = parser.Program();
            System.out.println(e.toString(new JsonShowHelper()));
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            System.out.println("Syntax check failed: " + e.getMessage());
            System.exit(1);
        }
    }
}

PARSER_END(SyntaxChecker)

TOKEN_MGR_DECLS : {
    static int commentNesting = 0;
}

SKIP : {
    " "
|   "\t"
|   "\n"
|   "\r"
|   "\f"
}

SKIP : { /* COMMENTS */
    <"//" (~["\r", "\n"])*>
|   "/*" { ++commentNesting; } : IN_COMMENT
}

<IN_COMMENT> SKIP : {
    "/*" { ++commentNesting; }
|   "*/" { --commentNesting; if (commentNesting == 0) SwitchTo(DEFAULT); }
|   <~[]>
}

TOKEN: {
    <LP: "("> | <RP: ")">
|   <LB: "{"> | <RB: "}">
|   <ADD_OP: "+">
|   <SUB_OP: "-">
|   <COMP_OP: "==" | "!=">
|   <COMP_NUM_OP: "<" | "<=" | ">" | ">=">
|   <LOGI_OP: "&&" | "||">
|   <NOT_OP: "~">
|   <EQ_OP: "=">
|   <COL: ":">
|   <SEMIC: ";">
|   <BOOL_LIT:"true" | "false">
|   <VAR_MOD: "var" | "const">
|   <VOID: "void">
|   <VAR_TYPE: "boolean" | "integer">
|   <MAIN: "main">
|   <IF: "if">
|   <ELSE: "else">
|   <WHILE: "while">
|   <SK: "skip">
|   <RET: "return">
|   <NUM: (["1"-"9"] (["0"-"9"])* | "0")>
|   <IDENTIFIER: ["a"-"z"] (["a"-"z"] | ["0"-"9"] | "_")*>
}

/**
ENTRY POINT
<Program> ::= <Condition>
 */
Expression Program(): {
    Expression e;
}
{
    e = Condition() <EOF> { return e; }
}


/**
<Condition> ::= <Condition1> <Condition_>
 */
Expression Condition(): {
    Expression e1, e2;
}
{
    e1 = Condition1() e2 = Condition_(e1) { return e2; }
}

/**
<Condition1> ::= ~ <Comparison>
<Condition1> ::= <Comparison>
 */
Expression Condition1(): {
    Expression e1;
}
{
    <NOT_OP> e1 = Comparison() { return new UnaryExpression("~", e1); }
|    e1 = Comparison() { return e1; }
}

/**
<Condition_> ::= && <Comparison> <Condition_>
<Condition_> ::= || <Comparison> <Condition_>
 */
Expression Condition_(Expression e1): {
    Token t;
    Expression e2, ef;
}
{
    t = <LOGI_OP> e2 = Comparison() ef = Condition_(new LogicalExpression(t.toString(), e1, e2)) { return ef; }
|   { return e1; }
}


/**
<Comparison> ::= <NumComparison> <Comparison_>
 */
Expression Comparison(): {
    Expression e1, e2;
}
{
    e1 = NumComparison() e2 = Comparison_(e1) { return e2; }
}

/**
<Comparison_> ::= == <NumComparison> <Comparison_>
<Comparison_> ::= != <NumComparison> <Comparison_>
 */
Expression Comparison_(Expression e1): {
    Token t;
    Expression e2, ef;
}
{
    t = <COMP_OP> e2 = NumComparison() ef = Comparison_(new BinaryExpression(t.toString(), e1, e2)) { return ef; }
|   { return e1; }
}

/**
<NumComparison> ::= <Expression> <NumComparison_>
 */
Expression NumComparison(): {
    Expression e1, e2;
}
{
    e1 = Expression() e2 = NumComparison_(e1) { return e2; }
}

/**
<NumComparison_> ::= <  <NumComparison> <NumComparison_>
<NumComparison_> ::= <= <NumComparison> <NumComparison_>
<NumComparison_> ::= >  <NumComparison> <NumComparison_>
<NumComparison_> ::= >= <NumComparison> <NumComparison_>
 */
Expression NumComparison_(Expression e1): {
    Token t;
    Expression e2, ef;
}
{
    t = <COMP_NUM_OP> e2 = Expression() ef = NumComparison_(new BinaryExpression(t.toString(), e1, e2)) { return ef; }
|   { return e1; }
}

/**
<Expression> ::= <Fragment> <Expression_>
 */
Expression Expression(): {
    Expression e1, e2;
}
{
    e1 = Fragment() e2 = Expression_(e1) { return e2; }
}

/**
<Expression_> ::= + <Fragment> <Expression_>
<Expression_> ::= - <Fragment> <Expression_>
 */
Expression Expression_(Expression e1): {
    Expression e2, ef;
}
{
    <ADD_OP> e2 = Fragment() ef = Expression_(new BinaryExpression("+", e1, e2)) { return ef;}
|   <SUB_OP> e2 = Fragment() ef = Expression_(new BinaryExpression("-", e1, e2)) { return ef;}
|   { return e1; }
}

/**
<Fragment> ::= <SubFragment>
<Fragment> ::= - <SubFragment>
<Fragment> ::= Bool_Lit
<Fragment> ::= ( <Condition> )
 */
Expression Fragment(): {
    Token t;
    Expression e;
}
{
    e = SubFragment()           { return e; }
|   <SUB_OP> e = SubFragment()  { return new UnaryExpression("-", e); }
|   t = <BOOL_LIT>              { return new Bool(t.toString().equals("true")); }
|   <LP> e = Condition() <RP>   { return e; }
}

/**
<SubFragment> ::= Identifier
<SubFragment> ::= Number
 */
Expression SubFragment(): {
    Token t;
}
{
    t = <IDENTIFIER>            { return new Identifier(t); }
|   t = <NUM>                   { return new Number(t.toString()); }
}
