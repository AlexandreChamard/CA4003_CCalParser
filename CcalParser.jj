
options
{
IGNORE_CASE = true;
}

PARSER_BEGIN(SyntaxChecker)

import java.util.ArrayList;

//////////////////
///    MAIN    ///
//////////////////
public class SyntaxChecker {
    static void help() {
            System.out.println("");
            System.out.println("USAGE:");
            System.out.println("\tjava SyntaxChecker [inputfile.ccal] [--debug [Expression | Condition]]");
            System.out.println("");
            System.out.println("  -h --help:\tshow help.");
            System.out.println("  --debug:\tparse only the given type.");
            System.out.println("");
    }

    static int parseArgs(String[] args) {
        if (args.length == 0)
            return 1; // get input from prompt
        if (args[0].equals("-h") || args[0].equals("--help"))
            return 4; // show help
        if (args.length == 1)
            return 3; // default program
        if (args.length == 2 && args[0].equals("--debug"))
            return 0; // get input from prompt + use debug feature
        if (args.length == 3 && args[1].equals("--debug"))
            return 2; // use debug feature
        return -1; // show help and return 2
    }

    static void invalidArgument(String msg) {
        System.out.println("Error: "+msg);
        help();
        System.exit(2);
    }

    public static void main(String[] args) {
        SyntaxChecker parser;
        String mod = "Program";

        switch (parseArgs(args)) {
            case 0: // get input from prompt + use debug feature
                mod = args[1];
            case 1: // get input from prompt
                System.out.println("SLP Parser: Reading from standard input...");
                parser = new SyntaxChecker(System.in);
                break;
            case 2: // use debug feature
                mod = args[2];
            case 3: // default program
                try {
                    parser = new SyntaxChecker(new java.io.FileInputStream(args[0]));
                } catch (java.io.FileNotFoundException e) {
                    System.out.println("SLP Parser: File " + args[0] + " not found.");
                    System.exit(1);
                    return; // avoid error msg
                }
                break;
            case 4: // show help
                help();
                return;
            default: // invalid arguments
                invalidArgument("invalid arguments.");
                return; // avoid error msg
        }
        try {
            Show e;
            switch (mod) {
                case "Program":
                    e = parser.Program();
                    break;
                case "Condition":
                    e = parser.DCondition();
                    break;
                case "Expression":
                    e = parser.DExpression();
                    break;
                case "Identifier":
                    e = parser.SubFragment();
                    break;
                default:
                    invalidArgument("invalid debug mod.");
                    return; // avoid error msg
            }
            System.out.println(e.toString(new JsonShowHelper()));
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            System.out.println("Syntax check failed: " + e.getMessage());
            System.exit(1);
        }
    }
}

PARSER_END(SyntaxChecker)

TOKEN_MGR_DECLS : {
    static int commentNesting = 0;
}

SKIP : {
    " "
|   "\t"
|   "\n"
|   "\r"
|   "\f"
}

SKIP : { /* COMMENTS */
    <"//" (~["\r", "\n"])*>
|   "/*" { ++commentNesting; } : IN_COMMENT
}

<IN_COMMENT> SKIP : {
    "/*" { ++commentNesting; }
|   "*/" { --commentNesting; if (commentNesting == 0) SwitchTo(DEFAULT); }
|   <~[]>
}

TOKEN: {
    "(" | ")"
|   "{" | "}"
|   "+"
|   "-"
|   <COMP_OP: "==" | "!=">
|   <COMP_NUM_OP: "<" | "<=" | ">" | ">=">
|   <LOGI_OP: "&&" | "||">
|   "~"
|   "="
|   ","
|   ":"
|   ";"
|   <BOOL_LIT: "true" | "false">
|   "var"
|   "const"
|   "void"
|   <VAR_TYPE: "boolean" | "integer">
|   "main"
|   "if"
|   "else"
|   "while"
|   "skip"
|   "return"
|   <NUM: (["1"-"9"] (["0"-"9"])* | "0")>
|   <IDENTIFIER: ["a"-"z"] (["a"-"z"] | ["0"-"9"] | "_")*>
}

/**
ENTRY POINT
<Program> ::= <Condition> <EOF>
 */
Program Program(): {
    StatementBlock dl, fl;
    MainFunction mf;
    SymbolTracker st = SymbolTracker.getInstance();
    st.newBlock();
}
{
    dl = DeclList()
    fl = FunctionList()
    mf = MainFunc()
    <EOF> {
        dl.addBack(fl);
        dl.addBack(mf);
        st.deleteBlock();
        return new Program(dl);
    }
}

StatementBlock DeclList(): {
    Statement d;
    StatementBlock ds;
}
{
    d = Decl() ";" ds = DeclList()      { ds.addFront(d); return ds; }
|                                       { return new StatementBlock(); }
}

VariableDeclaration Decl(): {
    VariableDeclaration v;
}
{
    v = VarDecl()                       { return v; }
|   v = ConstDecl()                     { return v; }
}

VariableDeclaration VarDecl(): {
    Token id, t;
}
{
    "var" id = <IDENTIFIER> ":" t = <VAR_TYPE> { return new VariableDeclaration(id, t); }
}

VariableDeclaration ConstDecl(): {
    Token id, t;
    Expression e;
}
{
    "const" id = <IDENTIFIER> ":" t = <VAR_TYPE> "=" e = PExpression() { return new VariableDeclaration(id, t, e); }
}

StatementBlock FunctionList(): {
    Statement f;
    StatementBlock fs;
}
{
    f = Function() fs = FunctionList()  {fs.addFront(f); return fs; }
|                                       { return new StatementBlock(); }
}

FunctionDeclaration Function(): {
    Token t, id;
    ArrayList<VariableDeclaration> ps;
    StatementBlock dl, sb;
    Expression r;

    SymbolTracker st = SymbolTracker.getInstance();
    st.newBlock();
}
{
    t = <VAR_TYPE> id = <IDENTIFIER> "(" ps = ParamList() ")" "{"
        dl = DeclList()
        sb = StatementBlock()
        "return" "(" r = PExpression() ")" ";"
    "}" {
        if (r.getType() != Typeable.stringToType(t.toString()))
            throw new ParseException("return type does not match with function type.");
        dl.addBack(sb);
        dl.addBack(new ReturnStatement(r));
        st.deleteBlock();
        return new FunctionDeclaration(id, t.toString(), ps, dl);
    }

|   "void" id = <IDENTIFIER> "(" ps = ParamList() ")" "{"
        dl = DeclList()
        sb = StatementBlock()
        "return" "(" ")" ";"
    "}" {
        dl.addBack(sb);
        st.deleteBlock();
        return new FunctionDeclaration(id, "void", ps, dl);
    }
}

MainFunction MainFunc(): {
    StatementBlock dl, sb;

    SymbolTracker st = SymbolTracker.getInstance();
    st.newBlock();
}
{
    "main" "{"
        dl = DeclList()
        sb = StatementBlock()
    "}" {
        dl.addBack(sb);
        st.deleteBlock();
        return new MainFunction(dl);
    }
}

ArrayList<VariableDeclaration> ParamList(): {
    ArrayList<VariableDeclaration> ps;
}
{
    ps = NempParameterList()    { return ps; }
|                               { return new ArrayList<VariableDeclaration>(); }
}

ArrayList<VariableDeclaration> NempParameterList(): {
    Token id, t;
    ArrayList<VariableDeclaration> ps;
}
{
    id = <IDENTIFIER> ":" t = <VAR_TYPE> ps = NempParameterList1() { ps.add(0, new VariableDeclaration(id, t)); return ps; }
}

ArrayList<VariableDeclaration> NempParameterList1(): {
    ArrayList<VariableDeclaration> ps;
}
{
    "," ps = NempParameterList()    { return ps; }
|                                   { return new ArrayList<VariableDeclaration>(); }
}

StatementBlock StatementBlock(): {
    StatementBlock sb;
    Statement s;

    SymbolTracker st = SymbolTracker.getInstance();
    st.newBlock();
}
{
    s = Statement() sb = StatementBlock()   { sb.addFront(s); st.deleteBlock(); return sb; }
|                                           { st.deleteBlock(); return new StatementBlock(); }
}

Statement Statement(): {
    Token id;
    Statement s;
}
{
    id = <IDENTIFIER> s = Statement1(new Identifier(id))    { return s; }
|   "{" s = StatementBlock() "}"                            { return s; }
|   s = IfStatement()                                       { return s; }
|   s = WhileStatement()                                    { return s; }
|   "skip " ";"                                             { return new SkipStatement(); }
}

IfStatement IfStatement(): {
    Expression c;
    StatementBlock sb, sb1;

    SymbolTracker st = SymbolTracker.getInstance();
    st.newBlock();
}
{
    "if" c = PCondition() "{" sb = StatementBlock() "}" "else" "{" sb1 = StatementBlock() "}"    { st.deleteBlock(); return new IfStatement(c, sb, sb1); }
}

WhileStatement WhileStatement(): {
    Expression c;
    StatementBlock sb;

    SymbolTracker st = SymbolTracker.getInstance();
    st.newBlock();
}
{
    "while" c = PCondition() "{" sb = StatementBlock() "}"  { st.deleteBlock(); return new WhileStatement(c, sb); }
}

Statement Statement1(Identifier id): {
    Expression e;
    ArrayList<Identifier> args;
}
{
    "=" e = PExpression() ";"        { return new ExpressionStatement(new AssignmentExpression(id, e)); }
|   "(" args = ArgList() ")" ";"    { return new ExpressionStatement(new CallExpression(id, args)); }
}

ArrayList<Identifier> ArgList(): {
    ArrayList<Identifier> args;
}
{
    args = NempArgList()    { return args; }
|                           { return new ArrayList<Identifier>(); }
}

ArrayList<Identifier> NempArgList(): {
    Token arg;
    ArrayList<Identifier> args;
}
{
    arg = <IDENTIFIER> args = NempArgList1()    { args.add(0, new Identifier(arg)); return args; }
}

ArrayList<Identifier> NempArgList1(): {
    ArrayList<Identifier> args;
}
{
    "," args = NempArgList()    { return args;}
|                               { return new ArrayList<Identifier>(); }
}

/**
subject condition
<PCondition> ::= <Condition> <EOF>
 */
Expression PCondition(): {
    Expression e;
}
{
    e = Condition() {
        if (e.getType() != Type.BOOLEAN || e.isLiteral() == true)
            throw new ParseException("invalid condition.");
        return e;
    }
}

/**
subject Expression
<PExpression> ::= <Expression> <EOF>
 */
Expression PExpression(): {
    Expression e;
}
{
    e = Expression() {
        Type t = e.getType();
        if ((t != Type.INTEGER && t != Type.BOOLEAN)
        || (t == Type.BOOLEAN && e.isLiteral() == false))
            throw new ParseException("invalid expression.");
        return e;
    }
}


/**
<Condition> ::= <Condition1> <Condition_>
 */
Expression Condition(): {
    Expression e1, e2;
}
{
    e1 = Condition1() e2 = Condition_(e1) { return e2; }
}

/**
<Condition1> ::= ~ <Comparison>
<Condition1> ::= <Comparison>
 */
Expression Condition1(): {
    Expression e1;
}
{
    "~" e1 = Comparison() { return new UnaryExpression("~", e1); }
|    e1 = Comparison() { return e1; }
}

/**
<Condition_> ::= && <Comparison> <Condition_>
<Condition_> ::= || <Comparison> <Condition_>
 */
Expression Condition_(Expression e1): {
    Token t;
    Expression e2, ef;
}
{
    t = <LOGI_OP> e2 = Comparison() ef = Condition_(new LogicalExpression(t.toString(), e1, e2)) { return ef; }
|   { return e1; }
}


/**
<Comparison> ::= <NumComparison> <Comparison_>
 */
Expression Comparison(): {
    Expression e1, e2;
}
{
    e1 = NumComparison() e2 = Comparison_(e1) { return e2; }
}

/**
<Comparison_> ::= == <NumComparison> <Comparison_>
<Comparison_> ::= != <NumComparison> <Comparison_>
 */
Expression Comparison_(Expression e1): {
    Token t;
    Expression e2, ef;
}
{
    t = <COMP_OP> e2 = NumComparison() ef = Comparison_(new BinaryExpression(t.toString(), e1, e2)) { return ef; }
|   { return e1; }
}

/**
<NumComparison> ::= <Expression> <NumComparison_>
 */
Expression NumComparison(): {
    Expression e1, e2;
}
{
    e1 = Expression() e2 = NumComparison_(e1) { return e2; }
}

/**
<NumComparison_> ::= <  <NumComparison> <NumComparison_>
<NumComparison_> ::= <= <NumComparison> <NumComparison_>
<NumComparison_> ::= >  <NumComparison> <NumComparison_>
<NumComparison_> ::= >= <NumComparison> <NumComparison_>
 */
Expression NumComparison_(Expression e1): {
    Token t;
    Expression e2, ef;
}
{
    t = <COMP_NUM_OP> e2 = Expression() ef = NumComparison_(new BinaryExpression(t.toString(), e1, e2)) { return ef; }
|   { return e1; }
}

/**
<Expression> ::= <Fragment> <Expression_>
 */
Expression Expression(): {
    Expression e1, e2;
}
{
    e1 = Fragment() e2 = Expression_(e1) { return e2; }
}

/**
<Expression_> ::= + <Fragment> <Expression_>
<Expression_> ::= - <Fragment> <Expression_>
 */
Expression Expression_(Expression e1): {
    Expression e2, ef;
}
{
    "+" e2 = Fragment() ef = Expression_(new BinaryExpression("+", e1, e2)) { return ef;}
|   "-" e2 = Fragment() ef = Expression_(new BinaryExpression("-", e1, e2)) { return ef;}
|   { return e1; }
}

/**
<Fragment> ::= <SubFragment>
<Fragment> ::= - <SubFragment>
<Fragment> ::= Bool_Lit
<Fragment> ::= ( <Condition> )
 */
Expression Fragment(): {
    Token t;
    Expression e;
}
{
    e = SubFragment()           { return e; }
|   "-" e = SubFragment()       { return new UnaryExpression("-", e); }
|   t = <BOOL_LIT>              { return new Bool(t.toString().equals("true")); }
|   "(" e = Condition() ")"     { return e; }
}

/**
<SubFragment> ::= Identifier
<SubFragment> ::= Number
 */
Expression SubFragment(): {
    Token t;
}
{
    t = <IDENTIFIER>            { return new Identifier(t); }
|   t = <NUM>                   { return new Number(t.toString()); }
}

/**
DEBUG
 */
Expression DExpression(): {
    Expression e;
}
{
    e = PExpression() <EOF> { return e; }
}

Expression DCondition(): {
    Expression e;
}
{
    e = PCondition() <EOF> { return e; }
}